<!DOCTYPE html><html data-pathToRoot="../../"><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>快速开始</title><link rel="shortcut icon" type="image/x-icon" href="../../favicon.ico"></link><script type="text/javascript" src="../../scripts/theme.js"></script><script type="text/javascript" src="../../scripts/searchData.js" defer="true"></script><script type="text/javascript" src="../../scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="../../styles/theme/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/components/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="../../styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="../../styles/nord-light.css"></link><link rel="stylesheet" href="../../styles/dotty-icons.css"></link><link rel="stylesheet" href="../../styles/filter-bar.css"></link><link rel="stylesheet" href="../../styles/code-snippets.css"></link><link rel="stylesheet" href="../../styles/searchbar.css"></link><link rel="stylesheet" href="../../styles/social-links.css"></link><link rel="stylesheet" href="../../styles/versions-dropdown.css"></link><link rel="stylesheet" href="../../styles/content-contributors.css"></link><link rel="stylesheet" href="../../styles/fontawesome.css"></link><script type="text/javascript" src="../../hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="../../scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="../../scripts/ux.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/component.js" defer="true"></script><script type="text/javascript" src="../../scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="../../scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="../../scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="../../scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="../../scripts/data.js" defer="true"></script><link rel="stylesheet" href="../../styles/staticsitestyles.css"></link><script>var pathToRoot = "../../";</script><meta charset="utf-8"> 
<title>Hello, world!</title></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="../../home.html" class="logo-container"><span class="project-name h300">otavia</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.3.2-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">otavia</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="../index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="../../index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 "><span class="nh de"><a href="../quick_start.html"><span>Quick Start</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="../core_concept.html"><span>Core Concept</span></a></span></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../guide/index.html"><span>Guide</span></a></span><div class="ni n1 "><span class="nh de"><a href="../guide/actor_model.html"><span>Actor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/slf4a.html"><span>SLF4A</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../guide/serde.html"><span>Serde framework</span></a></span></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../module/index.html"><span>Modules</span></a></span><div class="ni n1 "><span class="nh de"><a href="../module/buffer.html"><span>Buffer</span></a></span></div></div><div class="ni n0 expanded"><span class="nh h100 expanded cs de"><button class="ar icon-button expanded"></button><a href="index.html"><span>中文文档</span></a></span><div class="ni n1 expanded"><span class="nh h100 selected de"><a href="#"><span>快速开始</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="core_concept.html"><span>核心概念</span></a></span></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="guide/index.html"><span>Guide</span></a></span><div class="ni n2 "><span class="nh de"><a href="guide/channel_pipeline.html"><span>Channel Pipeline</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/io_model.html"><span>IO Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/ioc.html"><span>Actor IOC </span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/message_model.html"><span>Message Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/reactor_model.html"><span>Reactor Model</span></a></span></div><div class="ni n2 "><span class="nh de"><a href="guide/slf4a.html"><span>SLF4A</span></a></span></div></div><div class="ni n1"><span class="nh de"><button class="ar icon-button "></button><a href="module/index.html"><span>Modules</span></a></span><div class="ni n2 "><span class="nh de"><a href="module/buffer.html"><span>Buffer</span></a></span></div></div></div><div class="ni n0"><span class="nh de"><button class="ar icon-button "></button><a href="../blog/index.html"><span>Blog</span></a></span><div class="ni n1 "><span class="nh de"><a href="../blog/2023/05/19/hello-world-blog.zh-cn.html"><span>你好世界</span></a></span></div><div class="ni n1 "><span class="nh de"><a href="../blog/2023/05/19/hello-world-blog.html"><span>hello world blog</span></a></span></div></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/otavia-projects/otavia"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="../index.html">otavia</a>/<a href="index.html">中文文档</a>/<a href="quick_start.html">快速开始</a></div><div id="content" class="body-medium"><div><section id="环境要求-1"> 
 <h2 class="h500"><a href="#环境要求-1" class="anchor"></a>环境要求</h2> 
 <p><img src="https://img.shields.io/badge/JDK-17%2B-blue" alt="Static Badge"> <img src="https://img.shields.io/badge/Scala-3.3%2B-blue" alt="Static Badge"></p> 
 <p><code>otavia</code> 虽然主要运行在JVM平台上，但是为了保证可靠的编译时类型安全，目前只支持 <code>Scala 3</code>, 如果您对 <code>Scala 3</code> 目前不是很熟悉，您可以参考以下资料进行学习。</p> 
 <ul> 
  <li>基础知识（对于学习 <code>otavia</code> 足够了）: <a href="https://docs.scala-lang.org/zh-cn/scala3/book/introduction.html">Scala 3 Book</a></li> 
  <li>高级知识：<a href="https://docs.scala-lang.org/scala3/reference/">Scala 3 Language Reference</a></li> 
 </ul> 
 <p>以下所有示例的源码可以在 <a href="https://github.com/otavia-projects/otavia-examples">otavia-examples</a> 中找到。</p> 
</section> 
<section id="添加依赖-1"> 
 <h2 class="h500"><a href="#添加依赖-1" class="anchor"></a>添加依赖</h2> 
 <p>如果您使用 sbt , 请添加以下依赖：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>libraryDependencies += "cc.otavia" %% "otavia-runtime" % "{version}"
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>如果您使用 mill：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>ivy"cc.otavia::otavia-runtime:{version}"
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>如果使用 maven:</p> 
 <div class="snippet mono-small-block"> 
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>&lt;dependency&gt;
</span><span line-number="2" class=""><span class="tooltip-container"></span>    &lt;groupId&gt;cc.otavia&lt;/groupId&gt;
</span><span line-number="3" class=""><span class="tooltip-container"></span>    &lt;artifactId&gt;otavia-runtime&lt;/artifactId&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>    &lt;version&gt;{version}&lt;/version&gt;
</span><span line-number="5" class=""><span class="tooltip-container"></span>&lt;/dependency&gt;
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
</section> 
<section id="简单的-ping-pong-actors-1"> 
 <h2 class="h500"><a href="#简单的-ping-pong-actors-1" class="anchor"></a>简单的 Ping-Pong Actors</h2> 
 <p>这个简单的示例定义了两个 <code>Actor</code>: <code>PingActor</code> 和 <code>PongActor</code>, <code>PingActor</code> 接收 <code>Start</code> 消息，并且向 <code>PongActor</code> 发送 <code>Ping</code> 消息， 每个发送的 <code>Ping</code> 消息都必须对应一个 <code>Pong</code> 回复消息。</p> 
</section> 
<section id="定义消息-1"> 
 <h3 class="h400"><a href="#定义消息-1" class="anchor"></a>定义消息</h3> 
 <p>根据以上描述，我们需要3种消息，这3种消息分别代表3种不同角色的消息，这也是 <code>otavia</code> 3种基本的消息类型。<code>Start</code> 消息是一种 <code>Notice</code> 消息， <code>Notice</code> 消息是 <code>otavia</code> 中一种不需要获得回复的消息，只要有相关 <code>Actor</code> 的地址， 您就可以向 <code>Actor</code> 发送 <code>Notice</code> 消息；<code>Ping</code> 是一种 <code>Ask</code> 消息，这种消息必须对应一种回复消息，如果一个 <code>Actor</code> 向 其他 <code>Actor</code> 发送了这种消息，就意味着他必须收到一个对应的回复消息（有点像方法定义中的方法参数）；<code>Pong</code> 是一种回复消息， 回复消息有点像方法定义中的返回值。</p> 
 <p><code>Start</code> 消息是 <code>Notice</code> 类型，所以必须继承 <code>Notice</code> trait</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Start(sid: Int) extends Notice
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><code>Pong</code> 必须继承 <code>Reply</code> trait, <code>Ping</code> 是 <code>Ask</code> 类型的消息，必须继承 <code>Ask</code> trait, <code>Ask</code> trait 带有一个类型约束， 用来描述这个 <code>Ask</code> 消息期望获得的回复的消息类型</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Pong(pingId: Int) extends Reply
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class Ping(id: Int) extends Ask[Pong]
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
</section> 
<section id="实现-actor-1"> 
 <h3 class="h400"><a href="#实现-actor-1" class="anchor"></a>实现 Actor</h3> 
 <p>有了消息之后，我们来定义我们 Actor。</p> 
 <p>首先我们确定我们的 <code>Actor</code> 能接收的消息类型，因为 <code>otavia</code> 是一种消息类型安全的 <code>Actor</code> 编程框架，所以我们先来确定每种 <code>Actor</code> 能接收的消息类型： <code>PingActor</code> 能接收 <code>Start</code> 消息和 <code>Pong</code> 消息，<code>PongActor</code> 接收 <code>Ping</code> 消息并且回复 <code>Pong</code> 消息。因为在 <code>otavia</code> 中回复消息通过 <code>Ask</code> 消息进行约束，所以在 <code>Actor</code> 的定义中就不需要对这种消息进行约束，由 于 <code>PingActor</code> 需要给 <code>PongActor</code> 发送消息，所以 <code>PingActor</code> 需要知道 <code>PongActor</code> 的地址。 大概能定义出我们 的Actor的类名及泛型参数如下：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="3" class=""><span class="tooltip-container"></span>}
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="6" class=""><span class="tooltip-container"></span>  // ...
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>这里出现了 <code>StateActor</code> 我们暂时可以先不用管，<code>otavia</code> 中的最终 <code>Actor</code> 必须继承 <code>StateActor</code> 或 <code>ChannelsActor</code>， <code>ChannelsActor</code> 是用于处理 IO 的 <code>Actor</code> , 其余所有的 <code>Actor</code> 都是 <code>StateActor</code>。</p> 
 <p>接下来让我们来实现具体的消息处理吧！</p> 
 <p>首先是 <code>PingActor</code> , 他需要处理 <code>Start</code> 消息，并且处理过程中需要发送 <code>Ping</code> 消息，然后等待 <code>Pong</code> 回复消息，然后结束 <code>Start</code> 消息的处理。</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def continueNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = FutureState(1)
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] if state.id == 1 =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="11" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="12" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="13" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="14" class=""><span class="tooltip-container"></span>      }
</span><span line-number="15" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="16" class=""><span class="tooltip-container"></span>  }
</span><span line-number="17" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><code>continueNotice</code> 是 <code>Actor</code> 处理 <code>Notice</code> 消息的入口，从其他地方发送来的 <code>Notice</code> 消息都会从这个方法传入 <code>Actor</code>, 接下来我们来实现 <code>PongActor</code>, <code>PongActor</code> 接收 <code>Ping</code> 这种 <code>Ask</code> 消息，然后回复一个 <code>Pong</code> <code>Reply</code> 消息：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PongActor() extends StateActor[Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def continueAsk(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    println(s"PongActor received ${stack.ask} message")
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println(s"PongActor reply ${stack.ask} with Pong message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`(Pong(stack.ask.id))
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p><code>continueAsk</code> 是 <code>Actor</code> 处理 <code>Ask</code> 消息的入口，从其他地方发送来的 <code>Ask</code> 消息都会从这个方法传入 <code>Actor</code>。</p> 
 <p>我们可以发现，处理消息 <code>continueXXX</code> 的方法并不是直接处理消息，而是将消息装入了 <code>Stack</code> 中，<code>Notice</code> 消息装入 <code>NoticeStack</code> 中，<code>Ask</code> 消息装入 <code>AskStack</code> 中。在 <code>otavia</code> 中，为了方便管理消息的依赖关系和发送 <code>Reply</code> 消息，引入了 <code>Stack</code> 这种数据结构，引入了 <code>Future</code> 来接收 <code>Ask</code> 消息的返回 <code>Reply</code> 消息（注意这里的 <code>Future</code> 不是 scala 标准库的 <code>Future</code>） ，为了等待 <code>Future</code> 达到可执行状态，引入了 <code>StackState</code> ， 一个 <code>StackState</code> 可以关联一个或者多个 <code>Future</code> , 只有当 <code>StackState</code> 的 <code>resumable</code> 方法为 <code>ture</code> 或者关联的所有的 <code>Future</code> 都达到完成状态的时候，这个 <code>Stack</code> 才可以继续被调度执行，<code>continueXXX</code> 每次执行的时候从一个状态开始，结束的时候返回 <code>Option[StackState]</code>， <code>return</code> 方法用于结束 <code>Stack</code>, 如果是 <code>AskStack</code>，<code>return</code> 方法用于发送 <code>AskStack</code> 中 <code>Ask</code> 消息的返回 <code>Reply</code> 消息。</p> 
 <p><img src="../../images/stack_resume.drawio.svg" alt=""></p> 
 <p>至此，我们需要的所有的 <code>Actor</code> 和消息都已经完全实现了。接下来，启动一个 <code>ActorSystem</code> 来运行这些 <code>Actor</code> 吧</p> 
</section> 
<section id="运行-actor-1"> 
 <h3 class="h400"><a href="#运行-actor-1" class="anchor"></a>运行 actor</h3> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>@main def run(): Unit = {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val system = ActorSystem()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val pongActor = system.buildActor(() =&gt; new PongActor())
</span><span line-number="4" class=""><span class="tooltip-container"></span>  val pingActor = system.buildActor(() =&gt; new PingActor(pongActor))
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  pingActor.notice(Start(88))
</span><span line-number="7" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>通过 <code>ActorSystem()</code> 我们就可以轻松创建一个 <code>ActorSystem</code>, <code>ActorSystem</code> 是 <code>otavia</code> 中 actor 的运行时容器， 一个 JVM 实例 只允许启动一个 <code>ActorSystem</code> 实例。通过 <code>ActorSystem</code> 的 <code>buildActor</code> 方法，我们可以实例化我们定义的 actor ， <code>buildActor</code> 方法并不会返回 actor 实例对象本身，相反他返回的是一个地址，我们可以通过这个地址发送对应 actor 能处理的消息。</p> 
 <p>以上的一切都是编译时类型安全的，如果您向 <code>buildActor</code> 返回的地址发送对应 actor 不能处理的消息，这将不能通过编译。如果您使用 <code>AskStack</code> 的 <code>return</code> 方法返回与对应 <code>Ask</code> 消息不匹配的 <code>Reply</code> 消息，这也将不能通过编译。</p> 
</section> 
<section id="接收多种类型消息的-actor-1"> 
 <h2 class="h500"><a href="#接收多种类型消息的-actor-1" class="anchor"></a>接收多种类型消息的 Actor</h2> 
 <p>以上的示例演示了处理一种消息类型的 actor， 但是在真实的场景中我们往往需要在一个 actor 中处理多种类型的消息。这在 <code>Scala 3</code> 中非常简单，而且由于 <code>Scala 3</code> 强大的 <code>Union Types</code> 和 <code>Intersection Types</code>，我们还可以做到处理多种消息的编译时类型安全。</p> 
 <p>假如我们需要实现一个 actor， 这个 actor 需要处理的消息为：接收 <code>Hello</code> 消息并且返回 <code>World</code> 消息， 接收 <code>Ping</code> 消息并且 返回 <code>Pong</code> 消息， 接收 <code>Echo</code> 消息并且不返回任何消息。</p> 
 <p>以上需求需要我们定义如下几种消息：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>case class Echo() extends Notice
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>case class World() extends Reply
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>case class Hello() extends Ask[World]
</span><span line-number="6" class=""><span class="tooltip-container"></span>
</span><span line-number="7" class=""><span class="tooltip-container"></span>case class Pong() extends Reply
</span><span line-number="8" class=""><span class="tooltip-container"></span>
</span><span line-number="9" class=""><span class="tooltip-container"></span>case class Ping() extends Ask[Pong]
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>然后来实现我们的 actor：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class MultiMsgActor() extends StateActor[Echo | Hello | Ping] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  override def continueNotice(stack: NoticeStack[Echo]): Option[StackState] = {
</span><span line-number="4" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Echo message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>    stack.`return`()
</span><span line-number="6" class=""><span class="tooltip-container"></span>  }
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>  override def continueAsk(stack: AskStack[Hello | Ping]): Option[StackState] = {
</span><span line-number="9" class=""><span class="tooltip-container"></span>    stack match {
</span><span line-number="10" class=""><span class="tooltip-container"></span>      case stack: AskStack[Hello] if stack.ask.isInstanceOf[Hello] =&gt; handleHello(stack)
</span><span line-number="11" class=""><span class="tooltip-container"></span>      case stack: AskStack[Ping] if stack.ask.isInstanceOf[Ping] =&gt; handlePing(stack)
</span><span line-number="12" class=""><span class="tooltip-container"></span>    }
</span><span line-number="13" class=""><span class="tooltip-container"></span>  }
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>  private def handleHello(stack: AskStack[Hello]): Option[StackState] = {
</span><span line-number="16" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Hello message")
</span><span line-number="17" class=""><span class="tooltip-container"></span>    stack.`return`(World())
</span><span line-number="18" class=""><span class="tooltip-container"></span>  }
</span><span line-number="19" class=""><span class="tooltip-container"></span>
</span><span line-number="20" class=""><span class="tooltip-container"></span>  private def handlePing(stack: AskStack[Ping]): Option[StackState] = {
</span><span line-number="21" class=""><span class="tooltip-container"></span>    println("MultiMsgActor received Ping message")
</span><span line-number="22" class=""><span class="tooltip-container"></span>    stack.`return`(Pong())
</span><span line-number="23" class=""><span class="tooltip-container"></span>  }
</span><span line-number="24" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
</section> 
<section id="计时-1"> 
 <h2 class="h500"><a href="#计时-1" class="anchor"></a>计时</h2> 
 <p><code>otavia</code> 运行时包含了一个强大的计时器组件 <code>Timer</code> ，您可以使用多种方式与 <code>Timer</code> 进行交互，以下将介绍主要的使用场景：</p> 
</section> 
<section id="处理注册的定时事件-1"> 
 <h3 class="h400"><a href="#处理注册的定时事件-1" class="anchor"></a>处理注册的定时事件</h3> 
 <p>Actor 有方法处理注册的定时事件，其定义为</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>protected def handleActorTimeout(timeoutEvent: TimeoutEvent): Unit = {}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>如果定时事件触发，<code>Timer</code> 将会发送 <code>TimeoutEvent</code> 事件给 actor 实例，最终超时事件将会通过 <code>handleActorTimeout</code> 方法传入 actor 中</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class TickActor() extends StateActor[Nothing] { // [Nothing] if no message need process!
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>  private var onceTickId: Long = 0
</span><span line-number="4" class=""><span class="tooltip-container"></span>  private var periodTickId: Long = 0
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>  override protected def afterMount(): Unit = {
</span><span line-number="7" class=""><span class="tooltip-container"></span>    onceTickId = timer.registerActorTimeout(TimeoutTrigger.DelayTime(1, TimeUnit.SECONDS), self)
</span><span line-number="8" class=""><span class="tooltip-container"></span>    periodTickId = timer.registerActorTimeout(TimeoutTrigger.DelayPeriod(2, 2, TimeUnit.SECONDS, TimeUnit.SECONDS), self)
</span><span line-number="9" class=""><span class="tooltip-container"></span>  }
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>  override protected def handleActorTimeout(timeoutEvent: TimeoutEvent): Unit = {
</span><span line-number="12" class=""><span class="tooltip-container"></span>    if (timeoutEvent.registerId == periodTickId) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>      println(s"period timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="14" class=""><span class="tooltip-container"></span>    } else if (timeoutEvent.registerId == onceTickId) {
</span><span line-number="15" class=""><span class="tooltip-container"></span>      println(s"once timeout event triggered at ${LocalDateTime.now()}")
</span><span line-number="16" class=""><span class="tooltip-container"></span>    } else {
</span><span line-number="17" class=""><span class="tooltip-container"></span>      println("Never run this")
</span><span line-number="18" class=""><span class="tooltip-container"></span>    }
</span><span line-number="19" class=""><span class="tooltip-container"></span>  }
</span><span line-number="20" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
</section> 
<section id="stack-sleep-1"> 
 <h3 class="h400"><a href="#stack-sleep-1" class="anchor"></a>Stack Sleep</h3> 
 <p>如果我们想让一个 <code>Stack</code> 等待一段时间才开始执行，我们可以让 <code>StackState</code> 关联到一个 <code>TimeoutEventFuture</code> , 这个 <code>Future</code> 会将超时事件作为结果。只有收到超时事件的时候，<code>TimeoutEventFuture</code> 才完成。</p> 
 <p>在之前的示例中，<code>PingActor</code> 处理 <code>Start</code> 消息的时候使用了 <code>FutureState</code> , 这是 <code>otavia</code> 定义的一些比较常用的状态类，如果 这些状态类不能满足您的需要，您也可以自定义 <code>StackState</code>。</p> 
 <p>让我们改造一下之前的 <code>PingActor</code>，现在我们要求这个Actor收到 <code>Start</code> 消息之后发送 <code>Ping</code> 请求，然后收到 <code>Pong</code> 消息的时候 同时需要等待2秒才能继续调度这个 <code>NoticeStack</code> 执行。</p> 
 <p>现在 <code>FutureState</code> 已经不能满足我们的需求了，因为其只绑定了一个 <code>ReplyFuture</code>, 现在我们不仅需要绑定 <code>ReplyFuture</code>，还需要 绑定 <code>TimeoutEventFuture</code>，只有这两种 <code>Future</code> 都完成的时候才开始执行这个 <code>Stack</code>。让我们来定义我们新的 <code>StackState</code> 吧。</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = ReplyFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = TimeoutEventFuture()
</span><span line-number="4" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>接下来，重新实现我们的 <code>PingActor</code></p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def continueNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = PongTimeoutState()
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.pongFuture)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      timer.sleepStack(state.timeoutFuture, 2 * 1000)
</span><span line-number="9" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="10" class=""><span class="tooltip-container"></span>    case state: PongTimeoutState =&gt;
</span><span line-number="11" class=""><span class="tooltip-container"></span>      val future = state.pongFuture
</span><span line-number="12" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="13" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="14" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="15" class=""><span class="tooltip-container"></span>      }
</span><span line-number="16" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="17" class=""><span class="tooltip-container"></span>  }
</span><span line-number="18" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>好了，完成了！现在我们的 <code>PingActor</code> 即使收到 <code>Pong</code> 回复消息，也要等待2秒这个 <code>Stack</code> 才会被继续调度执行。</p> 
</section> 
<section id="给-reply-消息设置超时-1"> 
 <h3 class="h400"><a href="#给-reply-消息设置超时-1" class="anchor"></a>给 Reply 消息设置超时</h3> 
 <p>有时候，当我们发送一个 <code>Ask</code> 消息，对面的 Actor 可能会耗时比较久，但是我们不想让我们的请求 Actor 等待太久，这种情况我们可以 怎么办呢？也许聪明的您已经想到答案了！<code>Stack</code> 怎么样到达可执行状态呢，之前我们讲过：</p> 
 <blockquote> 
  <p>一个 <code>StackState</code> 可以关联一个或者多个 <code>Future</code> , 只有当 <code>StackState</code> 的 <code>resumable</code> 方法为 <code>ture</code> 或者关联的所 有的 <code>Future</code> 都达到完成状态的时候，这个 <code>Stack</code> 才可以继续被调度执行。</p> 
 </blockquote> 
 <p>所以我们可以重载 <code>StackState</code> 的 <code>resumable</code> 方法！ 现在来重新定义一下我们 <code>PongTimeoutState</code></p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>class PongTimeoutState extends StackState {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  val pongFuture = ReplyFuture[Pong]()
</span><span line-number="3" class=""><span class="tooltip-container"></span>  val timeoutFuture = TimeoutEventFuture()
</span><span line-number="4" class=""><span class="tooltip-container"></span>
</span><span line-number="5" class=""><span class="tooltip-container"></span>  override def resumable(): Boolean = timeoutFuture.isDone
</span><span line-number="6" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>现在只要 <code>timeoutFuture</code> 完成，那么 <code>Stack</code> 就会被继续调度执行了。接下来我们只需检测我们的 <code>pongFuture.isDone</code> 判断 是否完成。</p> 
 <p>这的确是一种方法，但是考虑到这种超时需求比较常见，<code>otavia</code> 提供了更简单的方法，我们只需对最开始的 <code>PingActor</code> 进行一点点改动：</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>final class PingActor(pongActorAddress: Address[Ping]) extends StateActor[Start] {
</span><span line-number="2" class=""><span class="tooltip-container"></span>  override def continueNotice(stack: NoticeStack[Start]): Option[StackState] = stack.state match {
</span><span line-number="3" class=""><span class="tooltip-container"></span>    case _: StartState =&gt;
</span><span line-number="4" class=""><span class="tooltip-container"></span>      println("PingActor handle Start message")
</span><span line-number="5" class=""><span class="tooltip-container"></span>      println("PingActor send Ping Message")
</span><span line-number="6" class=""><span class="tooltip-container"></span>      val state = FutureState(1)
</span><span line-number="7" class=""><span class="tooltip-container"></span>      pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000)
</span><span line-number="8" class=""><span class="tooltip-container"></span>      state.suspend()
</span><span line-number="9" class=""><span class="tooltip-container"></span>    case state: FutureState[Pong] if state.id == 1 =&gt;
</span><span line-number="10" class=""><span class="tooltip-container"></span>      val future = state.future
</span><span line-number="11" class=""><span class="tooltip-container"></span>      if (future.isSuccess) {
</span><span line-number="12" class=""><span class="tooltip-container"></span>        println(s"PingActor received ${future.getNow} message success!")
</span><span line-number="13" class=""><span class="tooltip-container"></span>        assert(future.getNow.pingId == stack.ask.sid)
</span><span line-number="14" class=""><span class="tooltip-container"></span>      }
</span><span line-number="15" class=""><span class="tooltip-container"></span>      stack.`return`()
</span><span line-number="16" class=""><span class="tooltip-container"></span>  }
</span><span line-number="17" class=""><span class="tooltip-container"></span>}
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>注意到不同的地方了吗！<code>ask</code> 方法自带了一个超时参数!</p> 
 <div class="snippet mono-small-block" scala-snippet=""> 
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future, 2 * 1000) // new 
</span><span line-number="2" class=""><span class="tooltip-container"></span>pongActorAddress.ask(Ping(stack.notice.sid), state.future) // old
</span></code></pre> 
  <div class="buttons"></div> 
 </div> 
 <p>如果2秒后仍然没有收到 <code>Pong</code> 消息，那么这个 <code>Future</code> 将会被设置成完成状态，但是与之前不同的是我们不能从 <code>Future</code> 里面拿到 <code>Pong</code> 消息了，他的状态已经是失败了，即 <code>isDone=ture isSuccess=false isFailed=ture</code>。因为这个 <code>StackState</code> 只关联 了一个 <code>Future</code>，而这个 <code>Future</code> 已经是完成状态了，所以这个 <code>Stack</code> 就可以继续被调度执行了。</p> 
</section> 
<section id="actor-的生命周期-1"> 
 <h2 class="h500"><a href="#actor-的生命周期-1" class="anchor"></a>Actor 的生命周期</h2> 
 <p>在 <code>otavia</code> 中，用户不用花太多心思管理 actor 的生命周期，actor 实例仍然被 JVM 垃圾回收管理，只要这个 actor 没有地址引用他，那么这个 actor 实例将被 JVM 的垃圾回收系统自动回收。</p> 
 <p>Actor 里有如下几种方法可以在不同的生命周期过程中调用</p> 
 <ul> 
  <li><code>afterMount</code>:</li> 
  <li><code>beforeRestart</code>:</li> 
  <li><code>restart</code>:</li> 
  <li><code>afterRestart</code>:</li> 
  <li><code>AutoCleanable.clean</code>:</li> 
 </ul> 
 <p><img src="../../images/actor_life_cycle.drawio.svg" alt=""></p> 
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#环境要求-1">环境要求</a></li><li><a href="#添加依赖-1">添加依赖</a></li><li><a href="#简单的-ping-pong-actors-1">简单的 Ping-Pong Actors</a><ul><li><a href="#定义消息-1">定义消息</a></li><li><a href="#实现-actor-1">实现 Actor</a></li><li><a href="#运行-actor-1">运行 actor</a></li></ul></li><li><a href="#接收多种类型消息的-actor-1">接收多种类型消息的 Actor</a></li><li><a href="#计时-1">计时</a><ul><li><a href="#处理注册的定时事件-1">处理注册的定时事件</a></li><li><a href="#stack-sleep-1">Stack Sleep</a></li><li><a href="#给-reply-消息设置超时-1">给 Reply 消息设置超时</a></li></ul></li><li><a href="#actor-的生命周期-1">Actor 的生命周期</a></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/lampepfl/dotty"><button class="icon-button gh"></button></a><a href="https://twitter.com/scala_lang"><button class="icon-button twitter"></button></a><a href="https://discord.com/invite/scala"><button class="icon-button discord"></button></a><a href="https://gitter.im/scala/scala"><button class="icon-button gitter"></button></a><div class="text">Copyright (c) 2022, Yan Kun/Otavia Project</div></div><div class="text-mobile">Copyright (c) 2022, Yan Kun/Otavia Project</div></div></div></div></body></html>